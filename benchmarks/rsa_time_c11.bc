; ModuleID = 'rsa_time_c11.c'
source_filename = "rsa_time_c11.c"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

@.str = private unnamed_addr constant [9 x i8] c"%d: %lu\0A\00", align 1
@.str.1 = private unnamed_addr constant [42 x i8] c"avg. timing for %d-bit: %f, std. dev: %f\0A\00", align 1
@.str.2 = private unnamed_addr constant [4 x i8] c"%d \00", align 1
@.str.3 = private unnamed_addr constant [2 x i8] c"\0A\00", align 1

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i64 @elapsed(i32 %start_hi, i32 %start_lo, i32 %end_hi, i32 %end_lo) #0 {
entry:
  %start_hi.addr = alloca i32, align 4
  %start_lo.addr = alloca i32, align 4
  %end_hi.addr = alloca i32, align 4
  %end_lo.addr = alloca i32, align 4
  %start = alloca i64, align 8
  %end = alloca i64, align 8
  store i32 %start_hi, i32* %start_hi.addr, align 4
  store i32 %start_lo, i32* %start_lo.addr, align 4
  store i32 %end_hi, i32* %end_hi.addr, align 4
  store i32 %end_lo, i32* %end_lo.addr, align 4
  %0 = load i32, i32* %start_hi.addr, align 4
  %conv = zext i32 %0 to i64
  %shl = shl i64 %conv, 32
  %1 = load i32, i32* %start_lo.addr, align 4
  %conv1 = zext i32 %1 to i64
  %or = or i64 %shl, %conv1
  store i64 %or, i64* %start, align 8
  %2 = load i32, i32* %end_hi.addr, align 4
  %conv2 = zext i32 %2 to i64
  %shl3 = shl i64 %conv2, 32
  %3 = load i32, i32* %end_lo.addr, align 4
  %conv4 = zext i32 %3 to i64
  %or5 = or i64 %shl3, %conv4
  store i64 %or5, i64* %end, align 8
  %4 = load i64, i64* %end, align 8
  %5 = load i64, i64* %start, align 8
  %sub = sub i64 %4, %5
  ret i64 %sub
}

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @dec_to_bin(i32 %n, i32* %bin) #0 {
entry:
  %n.addr = alloca i32, align 4
  %bin.addr = alloca i32*, align 8
  %mask = alloca i32, align 4
  store i32 %n, i32* %n.addr, align 4
  store i32* %bin, i32** %bin.addr, align 8
  store i32 65536, i32* %mask, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32, i32* %mask, align 4
  %tobool = icmp ne i32 %0, 0
  br i1 %tobool, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %1 = load i32, i32* %mask, align 4
  %2 = load i32, i32* %n.addr, align 4
  %and = and i32 %1, %2
  %tobool1 = icmp ne i32 %and, 0
  %3 = zext i1 %tobool1 to i64
  %cond = select i1 %tobool1, i32 1, i32 0
  %4 = load i32*, i32** %bin.addr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %4, i32 1
  store i32* %incdec.ptr, i32** %bin.addr, align 8
  store i32 %cond, i32* %4, align 4
  %5 = load i32, i32* %mask, align 4
  %shr = ashr i32 %5, 1
  store i32 %shr, i32* %mask, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define dso_local void @decimal_to_binary(i32 %op1, i32* %aOp) #0 {
entry:
  %op1.addr = alloca i32, align 4
  %aOp.addr = alloca i32*, align 8
  %i = alloca i32, align 4
  store i32 %op1, i32* %op1.addr, align 4
  store i32* %aOp, i32** %aOp.addr, align 8
  store i32 0, i32* %i, align 4
  br label %do.body

do.body:                                          ; preds = %do.cond, %entry
  %0 = load i32, i32* %op1.addr, align 4
  %rem = srem i32 %0, 2
  %1 = load i32*, i32** %aOp.addr, align 8
  %2 = load i32, i32* %i, align 4
  %inc = add nsw i32 %2, 1
  store i32 %inc, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds i32, i32* %1, i64 %idxprom
  store i32 %rem, i32* %arrayidx, align 4
  %3 = load i32, i32* %op1.addr, align 4
  %shr = ashr i32 %3, 1
  store i32 %shr, i32* %op1.addr, align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body
  %4 = load i32, i32* %op1.addr, align 4
  %tobool = icmp ne i32 %4, 0
  br i1 %tobool, label %do.body, label %do.end

do.end:                                           ; preds = %do.cond
  ret void
}

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @modular_exponentiation(i32 %a, i32 %b, i32 %n) #0 {
entry:
  %a.addr = alloca i32, align 4
  %b.addr = alloca i32, align 4
  %n.addr = alloca i32, align 4
  %bb = alloca i32*, align 8
  %count = alloca i32, align 4
  %d = alloca i32, align 4
  %i = alloca i32, align 4
  %start_hi = alloca i32, align 4
  %start_lo = alloca i32, align 4
  %end_hi = alloca i32, align 4
  %end_lo = alloca i32, align 4
  %saved_stack = alloca i8*, align 8
  %__vla_expr0 = alloca i64, align 8
  %i5 = alloca i32, align 4
  %j = alloca i32, align 4
  %s = alloca i64, align 8
  %e = alloca i64, align 8
  %null = alloca i32, align 4
  %e28 = alloca i64, align 8
  %total = alloca i64, align 8
  %bits = alloca i32, align 4
  %avgs = alloca [2 x float], align 4
  %vars = alloca [2 x float], align 4
  %j41 = alloca i32, align 4
  %i46 = alloca i32, align 4
  %avg = alloca float, align 4
  %j75 = alloca i32, align 4
  %i82 = alloca i32, align 4
  %diff = alloca float, align 4
  %j117 = alloca i32, align 4
  store i32 %a, i32* %a.addr, align 4
  store i32 %b, i32* %b.addr, align 4
  store i32 %n, i32* %n.addr, align 4
  store i32 0, i32* %count, align 4
  store i32 1, i32* %d, align 4
  store i32 0, i32* %start_hi, align 4
  store i32 0, i32* %start_lo, align 4
  store i32 0, i32* %end_hi, align 4
  store i32 0, i32* %end_lo, align 4
  %0 = load i32, i32* %b.addr, align 4
  %conv = sitofp i32 %0 to double
  %call = call double @log(double %conv) #2
  %call1 = call double @log(double 2.000000e+00) #2
  %div = fdiv double %call, %call1
  %conv2 = fptosi double %div to i32
  %add = add nsw i32 %conv2, 1
  store i32 %add, i32* %count, align 4
  %1 = load i32, i32* %count, align 4
  %conv3 = sext i32 %1 to i64
  %mul = mul i64 4, %conv3
  %call4 = call noalias i8* @malloc(i64 %mul) #2
  %2 = bitcast i8* %call4 to i32*
  store i32* %2, i32** %bb, align 8
  %3 = load i32, i32* %b.addr, align 4
  %4 = load i32*, i32** %bb, align 8
  call void @decimal_to_binary(i32 %3, i32* %4)
  %5 = load i32, i32* %count, align 4
  %6 = zext i32 %5 to i64
  %7 = call i8* @llvm.stacksave()
  store i8* %7, i8** %saved_stack, align 8
  %8 = mul nuw i64 2, %6
  %vla = alloca i64, i64 %8, align 16
  store i64 %6, i64* %__vla_expr0, align 8
  store i32 0, i32* %i5, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc13, %entry
  %9 = load i32, i32* %i5, align 4
  %cmp = icmp slt i32 %9, 2
  br i1 %cmp, label %for.body, label %for.end15

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %j, align 4
  br label %for.cond7

for.cond7:                                        ; preds = %for.inc, %for.body
  %10 = load i32, i32* %j, align 4
  %11 = load i32, i32* %count, align 4
  %cmp8 = icmp slt i32 %10, %11
  br i1 %cmp8, label %for.body10, label %for.end

for.body10:                                       ; preds = %for.cond7
  %12 = load i32, i32* %i5, align 4
  %idxprom = sext i32 %12 to i64
  %13 = mul nsw i64 %idxprom, %6
  %arrayidx = getelementptr inbounds i64, i64* %vla, i64 %13
  %14 = load i32, i32* %j, align 4
  %idxprom11 = sext i32 %14 to i64
  %arrayidx12 = getelementptr inbounds i64, i64* %arrayidx, i64 %idxprom11
  store i64 0, i64* %arrayidx12, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body10
  %15 = load i32, i32* %j, align 4
  %inc = add nsw i32 %15, 1
  store i32 %inc, i32* %j, align 4
  br label %for.cond7

for.end:                                          ; preds = %for.cond7
  br label %for.inc13

for.inc13:                                        ; preds = %for.end
  %16 = load i32, i32* %i5, align 4
  %inc14 = add nsw i32 %16, 1
  store i32 %inc14, i32* %i5, align 4
  br label %for.cond

for.end15:                                        ; preds = %for.cond
  %17 = load i32, i32* %count, align 4
  %sub = sub nsw i32 %17, 1
  store i32 %sub, i32* %i, align 4
  br label %for.cond16

for.cond16:                                       ; preds = %for.inc39, %for.end15
  %18 = load i32, i32* %i, align 4
  %cmp17 = icmp sge i32 %18, 0
  br i1 %cmp17, label %for.body19, label %for.end40

for.body19:                                       ; preds = %for.cond16
  %19 = call { i32, i32 } asm sideeffect "CPUID\0A\09RDTSC\0A\09mov %edx, $0\0A\09mov %eax, $1\0A\09", "=r,=r,~{rax},~{rbx},~{rcx},~{rdx},~{dirflag},~{fpsr},~{flags}"() #2, !srcloc !2
  %asmresult = extractvalue { i32, i32 } %19, 0
  %asmresult20 = extractvalue { i32, i32 } %19, 1
  store i32 %asmresult, i32* %start_hi, align 4
  store i32 %asmresult20, i32* %start_lo, align 4
  %20 = load i32, i32* %d, align 4
  %21 = load i32, i32* %d, align 4
  %mul21 = mul nsw i32 %20, %21
  %22 = load i32, i32* %n.addr, align 4
  %rem = srem i32 %mul21, %22
  store i32 %rem, i32* %d, align 4
  %23 = load i32*, i32** %bb, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom22 = sext i32 %24 to i64
  %arrayidx23 = getelementptr inbounds i32, i32* %23, i64 %idxprom22
  %25 = load i32, i32* %arrayidx23, align 4
  %tobool = icmp ne i32 %25, 0
  br i1 %tobool, label %if.then, label %if.end

if.then:                                          ; preds = %for.body19
  %26 = load i32, i32* %d, align 4
  %27 = load i32, i32* %a.addr, align 4
  %mul24 = mul nsw i32 %26, %27
  %28 = load i32, i32* %n.addr, align 4
  %rem25 = srem i32 %mul24, %28
  store i32 %rem25, i32* %d, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body19
  %29 = call { i32, i32 } asm sideeffect "RDTSCP\0A\09mov %edx, $0\0A\09mov %eax, $1\0A\09CPUID\0A\09", "=r,=r,~{rax},~{rbx},~{rcx},~{rdx},~{dirflag},~{fpsr},~{flags}"() #2, !srcloc !3
  %asmresult26 = extractvalue { i32, i32 } %29, 0
  %asmresult27 = extractvalue { i32, i32 } %29, 1
  store i32 %asmresult26, i32* %end_hi, align 4
  store i32 %asmresult27, i32* %end_lo, align 4
  %30 = load i32, i32* %start_hi, align 4
  %31 = load i32, i32* %start_lo, align 4
  %32 = load i32, i32* %end_hi, align 4
  %33 = load i32, i32* %end_lo, align 4
  %call29 = call i64 @elapsed(i32 %30, i32 %31, i32 %32, i32 %33)
  store i64 %call29, i64* %e28, align 8
  %34 = load i32*, i32** %bb, align 8
  %35 = load i32, i32* %i, align 4
  %idxprom30 = sext i32 %35 to i64
  %arrayidx31 = getelementptr inbounds i32, i32* %34, i64 %idxprom30
  %36 = load i32, i32* %arrayidx31, align 4
  %37 = load i64, i64* %e28, align 8
  %call32 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([9 x i8], [9 x i8]* @.str, i32 0, i32 0), i32 %36, i64 %37)
  %38 = load i64, i64* %e28, align 8
  %39 = load i32*, i32** %bb, align 8
  %40 = load i32, i32* %i, align 4
  %idxprom33 = sext i32 %40 to i64
  %arrayidx34 = getelementptr inbounds i32, i32* %39, i64 %idxprom33
  %41 = load i32, i32* %arrayidx34, align 4
  %idxprom35 = sext i32 %41 to i64
  %42 = mul nsw i64 %idxprom35, %6
  %arrayidx36 = getelementptr inbounds i64, i64* %vla, i64 %42
  %43 = load i32, i32* %i, align 4
  %idxprom37 = sext i32 %43 to i64
  %arrayidx38 = getelementptr inbounds i64, i64* %arrayidx36, i64 %idxprom37
  store i64 %38, i64* %arrayidx38, align 8
  br label %for.inc39

for.inc39:                                        ; preds = %if.end
  %44 = load i32, i32* %i, align 4
  %dec = add nsw i32 %44, -1
  store i32 %dec, i32* %i, align 4
  br label %for.cond16

for.end40:                                        ; preds = %for.cond16
  store i64 0, i64* %total, align 8
  store i32 0, i32* %bits, align 4
  store i32 0, i32* %j41, align 4
  br label %for.cond42

for.cond42:                                       ; preds = %for.inc72, %for.end40
  %45 = load i32, i32* %j41, align 4
  %cmp43 = icmp slt i32 %45, 2
  br i1 %cmp43, label %for.body45, label %for.end74

for.body45:                                       ; preds = %for.cond42
  store i32 0, i32* %bits, align 4
  store i64 0, i64* %total, align 8
  store i32 0, i32* %i46, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc64, %for.body45
  %46 = load i32, i32* %i46, align 4
  %47 = load i32, i32* %count, align 4
  %cmp48 = icmp slt i32 %46, %47
  br i1 %cmp48, label %for.body50, label %for.end66

for.body50:                                       ; preds = %for.cond47
  %48 = load i32, i32* %j41, align 4
  %idxprom51 = sext i32 %48 to i64
  %49 = mul nsw i64 %idxprom51, %6
  %arrayidx52 = getelementptr inbounds i64, i64* %vla, i64 %49
  %50 = load i32, i32* %i46, align 4
  %idxprom53 = sext i32 %50 to i64
  %arrayidx54 = getelementptr inbounds i64, i64* %arrayidx52, i64 %idxprom53
  %51 = load i64, i64* %arrayidx54, align 8
  %tobool55 = icmp ne i64 %51, 0
  br i1 %tobool55, label %if.then56, label %if.end63

if.then56:                                        ; preds = %for.body50
  %52 = load i32, i32* %bits, align 4
  %inc57 = add nsw i32 %52, 1
  store i32 %inc57, i32* %bits, align 4
  %53 = load i32, i32* %j41, align 4
  %idxprom58 = sext i32 %53 to i64
  %54 = mul nsw i64 %idxprom58, %6
  %arrayidx59 = getelementptr inbounds i64, i64* %vla, i64 %54
  %55 = load i32, i32* %i46, align 4
  %idxprom60 = sext i32 %55 to i64
  %arrayidx61 = getelementptr inbounds i64, i64* %arrayidx59, i64 %idxprom60
  %56 = load i64, i64* %arrayidx61, align 8
  %57 = load i64, i64* %total, align 8
  %add62 = add nsw i64 %57, %56
  store i64 %add62, i64* %total, align 8
  br label %if.end63

if.end63:                                         ; preds = %if.then56, %for.body50
  br label %for.inc64

for.inc64:                                        ; preds = %if.end63
  %58 = load i32, i32* %i46, align 4
  %inc65 = add nsw i32 %58, 1
  store i32 %inc65, i32* %i46, align 4
  br label %for.cond47

for.end66:                                        ; preds = %for.cond47
  %59 = load i64, i64* %total, align 8
  %conv67 = sitofp i64 %59 to float
  %60 = load i32, i32* %bits, align 4
  %conv68 = sitofp i32 %60 to float
  %div69 = fdiv float %conv67, %conv68
  store float %div69, float* %avg, align 4
  %61 = load float, float* %avg, align 4
  %62 = load i32, i32* %j41, align 4
  %idxprom70 = sext i32 %62 to i64
  %arrayidx71 = getelementptr inbounds [2 x float], [2 x float]* %avgs, i64 0, i64 %idxprom70
  store float %61, float* %arrayidx71, align 4
  br label %for.inc72

for.inc72:                                        ; preds = %for.end66
  %63 = load i32, i32* %j41, align 4
  %inc73 = add nsw i32 %63, 1
  store i32 %inc73, i32* %j41, align 4
  br label %for.cond42

for.end74:                                        ; preds = %for.cond42
  store i32 0, i32* %j75, align 4
  br label %for.cond76

for.cond76:                                       ; preds = %for.inc114, %for.end74
  %64 = load i32, i32* %j75, align 4
  %cmp77 = icmp slt i32 %64, 2
  br i1 %cmp77, label %for.body79, label %for.end116

for.body79:                                       ; preds = %for.cond76
  %65 = load i32, i32* %j75, align 4
  %idxprom80 = sext i32 %65 to i64
  %arrayidx81 = getelementptr inbounds [2 x float], [2 x float]* %vars, i64 0, i64 %idxprom80
  store float 0.000000e+00, float* %arrayidx81, align 4
  store i32 0, i32* %bits, align 4
  store i32 0, i32* %i82, align 4
  br label %for.cond83

for.cond83:                                       ; preds = %for.inc107, %for.body79
  %66 = load i32, i32* %i82, align 4
  %67 = load i32, i32* %count, align 4
  %cmp84 = icmp slt i32 %66, %67
  br i1 %cmp84, label %for.body86, label %for.end109

for.body86:                                       ; preds = %for.cond83
  %68 = load i32, i32* %j75, align 4
  %idxprom87 = sext i32 %68 to i64
  %69 = mul nsw i64 %idxprom87, %6
  %arrayidx88 = getelementptr inbounds i64, i64* %vla, i64 %69
  %70 = load i32, i32* %i82, align 4
  %idxprom89 = sext i32 %70 to i64
  %arrayidx90 = getelementptr inbounds i64, i64* %arrayidx88, i64 %idxprom89
  %71 = load i64, i64* %arrayidx90, align 8
  %tobool91 = icmp ne i64 %71, 0
  br i1 %tobool91, label %if.then92, label %if.end106

if.then92:                                        ; preds = %for.body86
  %72 = load i32, i32* %j75, align 4
  %idxprom93 = sext i32 %72 to i64
  %73 = mul nsw i64 %idxprom93, %6
  %arrayidx94 = getelementptr inbounds i64, i64* %vla, i64 %73
  %74 = load i32, i32* %i82, align 4
  %idxprom95 = sext i32 %74 to i64
  %arrayidx96 = getelementptr inbounds i64, i64* %arrayidx94, i64 %idxprom95
  %75 = load i64, i64* %arrayidx96, align 8
  %conv97 = sitofp i64 %75 to float
  %76 = load i32, i32* %j75, align 4
  %idxprom98 = sext i32 %76 to i64
  %arrayidx99 = getelementptr inbounds [2 x float], [2 x float]* %avgs, i64 0, i64 %idxprom98
  %77 = load float, float* %arrayidx99, align 4
  %sub100 = fsub float %conv97, %77
  store float %sub100, float* %diff, align 4
  %78 = load float, float* %diff, align 4
  %79 = load float, float* %diff, align 4
  %mul101 = fmul float %78, %79
  %80 = load i32, i32* %j75, align 4
  %idxprom102 = sext i32 %80 to i64
  %arrayidx103 = getelementptr inbounds [2 x float], [2 x float]* %vars, i64 0, i64 %idxprom102
  %81 = load float, float* %arrayidx103, align 4
  %add104 = fadd float %81, %mul101
  store float %add104, float* %arrayidx103, align 4
  %82 = load i32, i32* %bits, align 4
  %inc105 = add nsw i32 %82, 1
  store i32 %inc105, i32* %bits, align 4
  br label %if.end106

if.end106:                                        ; preds = %if.then92, %for.body86
  br label %for.inc107

for.inc107:                                       ; preds = %if.end106
  %83 = load i32, i32* %i82, align 4
  %inc108 = add nsw i32 %83, 1
  store i32 %inc108, i32* %i82, align 4
  br label %for.cond83

for.end109:                                       ; preds = %for.cond83
  %84 = load i32, i32* %bits, align 4
  %conv110 = sitofp i32 %84 to float
  %85 = load i32, i32* %j75, align 4
  %idxprom111 = sext i32 %85 to i64
  %arrayidx112 = getelementptr inbounds [2 x float], [2 x float]* %vars, i64 0, i64 %idxprom111
  %86 = load float, float* %arrayidx112, align 4
  %div113 = fdiv float %86, %conv110
  store float %div113, float* %arrayidx112, align 4
  br label %for.inc114

for.inc114:                                       ; preds = %for.end109
  %87 = load i32, i32* %j75, align 4
  %inc115 = add nsw i32 %87, 1
  store i32 %inc115, i32* %j75, align 4
  br label %for.cond76

for.end116:                                       ; preds = %for.cond76
  store i32 0, i32* %j117, align 4
  br label %for.cond118

for.cond118:                                      ; preds = %for.inc130, %for.end116
  %88 = load i32, i32* %j117, align 4
  %cmp119 = icmp slt i32 %88, 2
  br i1 %cmp119, label %for.body121, label %for.end132

for.body121:                                      ; preds = %for.cond118
  %89 = load i32, i32* %j117, align 4
  %90 = load i32, i32* %j117, align 4
  %idxprom122 = sext i32 %90 to i64
  %arrayidx123 = getelementptr inbounds [2 x float], [2 x float]* %avgs, i64 0, i64 %idxprom122
  %91 = load float, float* %arrayidx123, align 4
  %conv124 = fpext float %91 to double
  %92 = load i32, i32* %j117, align 4
  %idxprom125 = sext i32 %92 to i64
  %arrayidx126 = getelementptr inbounds [2 x float], [2 x float]* %vars, i64 0, i64 %idxprom125
  %93 = load float, float* %arrayidx126, align 4
  %conv127 = fpext float %93 to double
  %call128 = call double @sqrt(double %conv127) #2
  %call129 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([42 x i8], [42 x i8]* @.str.1, i32 0, i32 0), i32 %89, double %conv124, double %call128)
  br label %for.inc130

for.inc130:                                       ; preds = %for.body121
  %94 = load i32, i32* %j117, align 4
  %inc131 = add nsw i32 %94, 1
  store i32 %inc131, i32* %j117, align 4
  br label %for.cond118

for.end132:                                       ; preds = %for.cond118
  %95 = load i32, i32* %d, align 4
  %96 = load i8*, i8** %saved_stack, align 8
  call void @llvm.stackrestore(i8* %96)
  ret i32 %95
}

; Function Attrs: nounwind
declare dso_local double @log(double) #1

; Function Attrs: nounwind
declare dso_local noalias i8* @malloc(i64) #1

; Function Attrs: nounwind
declare i8* @llvm.stacksave() #2

declare dso_local i32 @printf(i8*, ...) #3

; Function Attrs: nounwind
declare dso_local double @sqrt(double) #1

; Function Attrs: nounwind
declare void @llvm.stackrestore(i8*) #2

; Function Attrs: noinline nounwind optnone uwtable
define dso_local i32 @main() #0 {
entry:
  %retval = alloca i32, align 4
  %arr = alloca [16 x i32], align 16
  %b = alloca i32, align 4
  %i = alloca i32, align 4
  %a = alloca i32, align 4
  store i32 0, i32* %retval, align 4
  store i32 1023, i32* %b, align 4
  %0 = load i32, i32* %b, align 4
  %arraydecay = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i32 0, i32 0
  call void @dec_to_bin(i32 %0, i32* %arraydecay)
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %1 = load i32, i32* %i, align 4
  %cmp = icmp slt i32 %1, 16
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load i32, i32* %i, align 4
  %idxprom = sext i32 %2 to i64
  %arrayidx = getelementptr inbounds [16 x i32], [16 x i32]* %arr, i64 0, i64 %idxprom
  %3 = load i32, i32* %arrayidx, align 4
  %call = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.2, i32 0, i32 0), i32 %3)
  br label %for.inc

for.inc:                                          ; preds = %for.body
  %4 = load i32, i32* %i, align 4
  %inc = add nsw i32 %4, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %call1 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.3, i32 0, i32 0))
  %call2 = call i32 @modular_exponentiation(i32 7654351, i32 261632, i32 93093587)
  store i32 %call2, i32* %a, align 4
  %call3 = call i32 @modular_exponentiation(i32 987654351, i32 12345678, i32 93093587)
  store i32 %call3, i32* %a, align 4
  %5 = load i32, i32* %retval, align 4
  ret i32 %5
}

attributes #0 = { noinline nounwind optnone uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { nounwind }
attributes #3 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 8.0.1 (tags/RELEASE_801/final)"}
!2 = !{i32 -2143847027, i32 -2143847019, i32 -2143846987, i32 -2143846947, i32 -2143846907}
!3 = !{i32 -2143846775, i32 -2143846766, i32 -2143846726, i32 -2143846686, i32 -2143846654}
